#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №9. Реализация длительных операций.

**Цель:** Предоставить возможность выполннеия команд, для полного завершения которых требуется более одного вызова Execute.

**Результаты:** После выполнения работы Вы сможете:
1. Выполнять длительные опреации в отдельном потоке без монопольного использования потока в течение длительного времени.
3. Прерывать выполнение таких команд. 


## Задание.
Если для полного выполнения командв потребуется более одного вызова Execute, необходимо такую команду добавить в планировщик.

Для иллюстрации выполнненой работы определить команду

#!csharp

interface ICommand
{
    void Execute();
}

interface IScheduler
{
    bool HasCommand();
    ICommand Select();
    void Add(ICommand cmd);
}

#!csharp

using System.Collections.Concurrent;
using System.Threading;

class ServerThread
{
    public BlockingCollection<ICommand> queue = [];
    public Thread thread;
    public bool SoftStopflag = false;
    public Scheduler sched;

    public ServerThread(Scheduler sched)
    {
        this.sched = sched;
        thread = new Thread(RunServer);
        thread.Start();
    }

    public void RunServer()
    {
        while (true)
        {
            if (!sched.HasCommand() && queue.Count==0 && SoftStopflag) 
            {
                break;
            }
            ICommand com;

            if (sched.HasCommand()) com = sched.Select();

            else if (!queue.TryTake(out com))
            {
                Thread.Sleep(10);
                continue;
            }

            try
            {
                com.Execute();
            }
            catch (ThreadInterruptedException)
            {
                break;
            }
        }
    }

    public void AddCommand(ICommand com)
    {
        queue.Add(com);
    }
}

public class TestCommand(int id) : ICommand
{
    int counter = 0;

    public void Execute()
    {
        Console.WriteLine($"Поток {id} вызов {++counter}");
    }
}

class Scheduler : IScheduler
{
    BlockingCollection<ICommand> schQueue = [];

    public bool HasCommand() 
    {
        return schQueue.Count>0;
    }

    public ICommand Select()
    {
        return schQueue.Take();
    }

    public void Add(ICommand cmd)
    {
        schQueue.Add(cmd);
    }
}

class HardStopCommand(ServerThread serverThread) : ICommand
{
    ServerThread serverThread = serverThread;

    public void Execute()
    {
        throw new ThreadInterruptedException();
    }
}

class SoftStopCommand(ServerThread serverThread) : ICommand
{
    ServerThread serverThread = serverThread;

    public void Execute()
    {
        serverThread.SoftStopflag = true;
    }
}

class TestBaseCommand : ICommand
{
    public void Execute()
    {
        Console.WriteLine("Base test");
    }
}

class TestLongCommand(ICommand command, Scheduler scheduler, int counter) : ICommand
{
    int counter = counter;
    Scheduler scheduler = scheduler;

    public void Execute()
    {
        if (counter!=0)
        {
            command.Execute();
            counter--;
            if (counter!=0) scheduler.Add(this);
        }
    }
}

var shed = new Scheduler();
var serverThread = new ServerThread(shed);


for (int i = 0; i < 5; i++)
{
    serverThread.AddCommand(new TestLongCommand(new TestCommand(i+1),shed,3));
}

serverThread.AddCommand(new HardStopCommand(serverThread));

serverThread.thread.Join();

#!markdown

Необходимо проиллюстрировать выполнение 5 экземпляров TestCommand 3 раза, затем остановить поток с помощью HardStop.
