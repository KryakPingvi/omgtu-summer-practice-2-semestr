#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

// Install the ScottPlot NuGet package
#r "nuget:ScottPlot, 5.0.*"

// Setup a custom formatter to display plots as images
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);

#!csharp

using System.Threading;
using System.Diagnostics;
//
// Вычисление определенного интеграла
//
class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    public static double sum = 0.0;
    public static void SolveFunc(double a, double b, Func<double, double> function,double step) {
        double localsum = (function(a)+function(b))/2;
        double n = (b-a)/step;
        for (int i  = 1; i < n; i++){
            localsum += function(a + i*step);
        }
        localsum *= step;
        sum += localsum;
    }
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        Stopwatch stopWatch = new Stopwatch();
        stopWatch.Start();

        sum =0.0;
        double dn = (b-a)/threadsnumber;
        Thread[] threads = new Thread[threadsnumber];
        for (int i=0;i<threadsnumber;i++)
        {
            double start = a + i*dn;
            if (i==threadsnumber-1) threads[i] = new Thread(() => SolveFunc(start, b, function, step));
            else threads[i] = new Thread(() => SolveFunc(start, start+dn, function, step));
            threads[i].Start();
        }
        foreach (Thread thread in threads)
        {
            thread.Join();
        }
        return sum;
    }
}

#!csharp

#r "nuget: xunit, 2.8.1"

using Xunit;

var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2), 1e-4);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-5, 8), 1e-4);

Assert.Equal(50, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8), 1e-5);

#!csharp

//определяю минимальный размер шага на несимметричном интервале
var SIN = (double x) => Math.Sin(x);
Assert.Equal(1-Math.Cos(10), DefiniteIntegral.Solve(0, 10, SIN, 1e-6, 1), 1e-4);

Assert.Equal(1-Math.Cos(10), DefiniteIntegral.Solve(0, 10, SIN, 1e-5, 1), 1e-4);

Assert.Equal(1-Math.Cos(10), DefiniteIntegral.Solve(0, 10, SIN, 1e-4, 1), 1e-4);

Assert.Equal(1-Math.Cos(10), DefiniteIntegral.Solve(0, 10, SIN, 1e-3, 1), 1e-4);

Assert.Equal(1-Math.Cos(10), DefiniteIntegral.Solve(0, 10, SIN, 1e-2, 1), 1e-4);

//Assert.Equal(1-Math.Cos(10), DefiniteIntegral.Solve(0, 10, SIN, 1e-1, 1), 1e-4);
//как видно, ошибка вышла только на тесте, в котором я брал шаг 1e-5, значит достаточная точность получается при размере шага 1e-2

#!csharp

public long Sred(int potoks)
{
    int kolvosred = 1000;
    Stopwatch stopWatch = new Stopwatch();
    long[] vars = new long[kolvosred];
    
    for (int i=0;i<kolvosred;i++)
    {
        stopWatch.Start();
        double otvet = DefiniteIntegral.Solve(-100, 100, SIN, 1e-2, potoks);
        stopWatch.Stop();
        vars[i] = stopWatch.ElapsedTicks;
        stopWatch.Reset();
    }

    return Convert.ToInt64(vars.Average());
}

int potoks = 16;

long[] dataX = new long[potoks-1];
for (int i=2;i<=potoks;i++)
{
    dataX[i-2]=Sred(i);
}
long[] dataY = Enumerable.Range(2, potoks-1).Select(Convert.ToInt64).ToArray();

ScottPlot.Plot plt = new();
plt.Add.Scatter(dataX, dataY);

Console.WriteLine($"Наименьшее время достигается при {Array.IndexOf(dataX,dataX.Min())+2} потоках, количество тиков: {dataX.Min()}");

plt

#!csharp

public static double SolveOne(double a, double b, Func<double, double> function,double step) 
{
    double localsum = (function(a)+function(b))/2;
    double n = (b-a)/step;
    for (int i  = 1; i < n; i++){
        localsum += function(a + i*step);
    }
    localsum *= step;
    return localsum;
}

long SredOne()
{
    int kolvosred = 1000;
    Stopwatch stopWatch = new Stopwatch();
    long[] vars = new long[kolvosred];
    
    for (int i=0;i<kolvosred;i++)
    {
        stopWatch.Start();
        double otvet = SolveOne(-100, 100, SIN, 1e-2);
        stopWatch.Stop();
        vars[i] = stopWatch.ElapsedTicks;
        stopWatch.Reset();
    }

    return Convert.ToInt64(vars.Average());
}
double result = ((double)Sred(2)/SredOne()*100)-100;
Console.WriteLine($"Двупоточная программа быстрее однопоточной на: {result}%")

#!markdown

Summary
В п. 4 я выбрал размер шага 1e-2, проверив все шаги от 1e-6 до 1e-1, так как при размере шаге 1e-2 вычисление интеграла остается достаточно точным. 
В п. 5 я выбрал 2 потока, так как при построении графика чаще всего программа работает наименьшее время при двух потоках.
Скорость многопоточной версии: 3898 тиков, Двупоточная программа быстрее однопоточной на 89.5%. При пересчёте разницы скорости двупоточная программа всегда быстрее однопоточной больше чем на 15%
